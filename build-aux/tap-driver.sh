#! /bin/sh
# Copyright (C) 2011-2020 Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

# As a special exception to the GNU General Public License, if you
# distribute this file as part of a program that contains a
# configuration script generated by Autoconf, you may include it under
# the same distribution terms that you use for the rest of that program.

# This file is maintained in Automake, please report
# bugs to <bug-automake@gnu.org> or send patches to
# <automake-patches@gnu.org>.

scriptversion=2020-01-01.04; # UTC

# Make unconditional expansion of undefined variables an error.  This
# helps a lot in preventing typo-related bugs.
set -u

me=tap-driver.sh

fatal ()
{
  echo "$me: fatal: $*" >&2
  exit 1
}

usage_error ()
{
  echo "$me: $*" >&2
  print_usage >&2
  exit 2
}

print_usage ()
{
  cat <<END
Usage:
  tap-driver.sh --test-name=NAME --log-file=PATH --trs-file=PATH
                [--expect-failure={yes|no}] [--color-tests={yes|no}]
                [--enable-hard-errors={yes|no}] [--ignore-exit]
                [--diagnostic-string=STRING] [--merge|--no-merge]
                [--comments|--no-comments] [--] TEST-COMMAND
The '--test-name', '--log-file' and '--trs-file' options are mandatory.
END
}

test_name= # Used for reporting.
log_file=  # Where to save the output of the test script.
trs_file=  # Where to save the metadata of the test run.
expect_failure=no
color_tests=no
merge=yes
ignore_exit=no
comments=no
diag_string='#'
while test $# -gt 0; do
  case $1 in
  --help) print_usage; exit 0;;
  --version) echo "$me $scriptversion"; exit 0;;
  --test-name) test_name=$2; shift;;
  --log-file) log_file=$2; shift;;
  --trs-file) trs_file=$2; shift;;
  --color-tests) color_tests=$2; shift;;
  --expect-failure) expect_failure=$2; shift;;
  --enable-hard-errors) shift;;
  --merge) merge=yes;;
  --no-merge) merge=no;;
  --ignore-exit) ignore_exit=yes;;
  --comments) comments=yes;;
  --no-comments) comments=no;;
  --diagnostic-string) diag_string=$2; shift;;
  --) shift; break;;
  -*) usage_error "invalid option: '$1'";;
  esac
  shift
done

test $# -gt 0 || usage_error "missing test command"

case $expect_failure in
  yes|no) ;;
  *) usage_error "invalid value for '--expect-failure': '$expect_failure'";;
esac

case $color_tests in
  yes|no) ;;
  *) usage_error "invalid value for '--color-tests': '$color_tests'";;
esac

case $merge in
  yes|no) ;;
  *) usage_error "invalid value for '--merge': '$merge'";;
esac

case $ignore_exit in
  yes|no) ;;
  *) usage_error "invalid value for '--ignore-exit': '$ignore_exit'";;
esac

case $comments in
  yes|no) ;;
  *) usage_error "invalid value for '--comments': '$comments'";;
esac

if test $color_tests = yes; then
  # Keep this in sync with 'lib/am/check.am'.
  red='[0;31m' # Red.
  grn='[0;32m' # Green.
  lgn='[1;32m' # Light green.
  blu='[1;34m' # Blue.
  mgn='[0;35m' # Magenta.
  std='[m'     # No color.
else
  red= grn= lgn= blu= mgn= std=
fi

if test $merge = yes; then
  exec 5>&1
  exec 6>&2
  exec > "$log_file"
  exec 2>&1
  echo "$me: starting test(s) $test_name"
fi

# '$*' (rather than '$@') is used to avoid quoting issues with
# command arguments containing shell metacharacters.
exec 4>&1
res=0
"$@" ${1+"$@"} 4>&- 2>&1 | LC_ALL=C ${AM_TAP_AWK-awk} \
'
# TODO: the usages of "cat >&3" below could be optimized when using
#       GNU awk, to avoid the spawning of a shell process.
#       On the other hand, using "print" unconditionally could be more
#       problematic, due to filenames containing backslashes.

# Implementation note: in what follows, we avoid playing with $NF (the
# number of fields in the current record) since $NF is not guaranteed
# to be set correctly for lines that do not match the default field
# separator (e.g., lines with less fields, or with more fields, than
# expected).

# Defer initialization of variables to the BEGIN block.

BEGIN {

    # Whether we need to convert to a TAP format.
    do_tap = 0;

    # Whether we are still reading the header of a TAP stream.
    in_header = 0;

    # Whether the TAP plan has been seen or not.
    plan_seen = 0;

    # Whether the plan has been seen before any test line.
    plan_before_any_test = 0;

    # Whether a "Bail out!" directive has been seen.
    bail_out = 0;

    # Whether the test plan is a "SKIP" plan.
    skip_all = 0;

    # Number of test results seen.  This does not include skipped tests.
    test_results_count = 0;

    # Number of test results expected according to the plan.
    test_results_expected = 0;

    # Number of test lines seen.  This includes skipped tests.
    test_lines_count = 0;

    # Whether any test result has been seen already.
    any_test_seen = 0;

    # Whether any test has been skipped already.
    any_skip_seen = 0;

    # Whether any test has been failed already.
    any_fail_seen = 0;

    # Whether the TAP output contained any "TODO"/"SKIP" directive.
    any_todo_or_skip_seen = 0;

    # Whether the "No tests were run" message should be printed.
    no_tests_run = 0;

    # Whether the "No tests were run" message should be printed.
    no_results = 0;

    # Whether we should ignore the exit code of the test script.
    ignore_exit_code = '"$ignore_exit"';

    # Process the command line.
    test_name = "'"$test_name"'";
    if (test_name == "")
      test_name = "unnamed test";
    diag_prefix = "'"$diag_string"'";
    diag_len = length(diag_prefix);
    comments = '"$comments"';
}

# 'close enough' matching for TAP headers.
# See <http://testanything.org/tap-specification.html> for more details
# on the TAP format.
/^1\.\.[0-9]+[ \t]*$/ {
    # The line matches the form "1..$testcount".
    if (plan_seen) {
        print "ERROR: More than one test plan seen:";
        print "ERROR:   first: \"" plan_line "\"";
        print "ERROR:   later: \"" $0 "\"";
        err = 1;
        exit 1;
    }
    plan_line = $0;
    plan_seen = 1;
    plan_before_any_test = ! any_test_seen;
    sub(/[ \t]*$/, "", $0);
    test_results_expected = substr($0, 4) + 0;
    if (test_results_expected == 0) {
        no_tests_run = 1;
        if ($0 ~ /^1\.\.0+[ \t]+#[ \t]+[Ss][Kk][Ii][Pp]/) {
            # A SKIP plan, of the form "1..0 # SKIP" or similar.
            skip_all = 1;
            no_tests_run = 0;
        }
    }
    next;
}

/^Bail out!/ {
    # Bail out (as per the TAP specification).
    bail_out = 1;
    if (length($0) > 10)
        print substr($0, 11);
    err = 1;
    exit 1;
}

/^not[ \t]+ok/ {
    # The line is a failure test header.
    any_test_seen = 1;
    test_lines_count += 1;
    if ($0 ~ /^not[ \t]+ok[ \t]+[0-9]+[ \t]*$/ \
        || $0 ~ /^not[ \t]+ok[ \t]*$/) {
        # The line matches the form "not ok $testnum" or "not ok".
        test_results_count += 1;
        any_fail_seen = 1;
        report_failure(test_name, test_lines_count);
    }
    else if ($0 ~ /^not[ \t]+ok[ \t]+[0-9]+[ \t]+#[ \t]+[Ss][Kk][Ii][Pp]/ \
             || $0 ~ /^not[ \t]+ok[ \t]+#[ \t]+[Ss][Kk][Ii][Pp]/) {
        # The line matches the form "not ok $testnum # SKIP" or
        # "not ok # SKIP".
        any_skip_seen = 1;
        any_todo_or_skip_seen = 1;
    }
    else if ($0 ~ /^not[ \t]+ok[ \t]+[0-9]+[ \t]+#[ \t]+[Tt][Oo][Dd][Oo]/ \
             || $0 ~ /^not[ \t]+ok[ \t]+#[ \t]+[Tt][Oo][Dd][Oo]/) {
        # The line matches the form "not ok $testnum # TODO" or
        # "not ok # TODO".
        any_todo_or_skip_seen = 1;
    }
    else {
        # The line is a failure test header that does not match any of
        # the above more specific formats.
        test_results_count += 1;
        any_fail_seen = 1;
        report_failure(test_name, test_lines_count);
    }
    next;
}

/^ok/ {
    # The line is a success test header.
    any_test_seen = 1;
    test_lines_count += 1;
    if ($0 ~ /^ok[ \t]+[0-9]+[ \t]*$/ \
        || $0 ~ /^ok[ \t]*$/) {
        # The line matches the form "ok $testnum" or "ok".
        test_results_count += 1;
    }
    else if ($0 ~ /^ok[ \t]+[0-9]+[ \t]+#[ \t]+[Ss][Kk][Ii][Pp]/ \
             || $0 ~ /^ok[ \t]+#[ \t]+[Ss][Kk][Ii][Pp]/) {
        # The line matches the form "ok $testnum # SKIP" or "ok # SKIP".
        any_skip_seen = 1;
        any_todo_or_skip_seen = 1;
    }
    else if ($0 ~ /^ok[ \t]+[0-9]+[ \t]+#[ \t]+[Tt][Oo][Dd][Oo]/ \
             || $0 ~ /^ok[ \t]+#[ \t]+[Tt][Oo][Dd][Oo]/) {
        # The line matches the form "ok $testnum # TODO" or "ok # TODO".
        any_todo_or_skip_seen = 1;
    }
    else {
        # The line is a success test header that does not match any of
        # the above more specific formats.
        test_results_count += 1;
    }
    next;
}

# TAP headers were not found, so we are not looking at TAP format.
# Assume the first line of output is the first test result.
! do_tap && ! in_header {
    # If no TAP headers have been seen, and we are not already reading
    # the header of a TAP stream, assume that the input is not in the
    # TAP format, and convert it to a more-or-less equivalent TAP format.
    do_tap = 1;
    print "1..1";
    any_test_seen = 1;
    test_lines_count += 1;
    test_results_count += 1;
    test_results_expected = 1;
    if ($0 ~ /^(ERROR|FAIL):/) {
        # The line matches the form "ERROR: $message" or "FAIL: $message".
        any_fail_seen = 1;
        report_failure(test_name, test_lines_count);
        print "not ok 1 - " test_name;
    }
    else {
        # The line is not an error or failure message.
        print "ok 1 - " test_name;
    }
    next;
}

# We are still reading the header of a TAP stream.
in_header {
    if ($0 ~ /^[ \t]*#/) {
        # The line is a TAP comment.
        if (comments)
            print;
    }
    else if ($0 ~ /^[ \t]*$/) {
        # The line is empty.
        if (comments)
            print;
    }
    else {
        # The line is not a TAP comment, nor is it empty.  We have reached
        # the end of the header.
        in_header = 0;
    }
    next;
}

# We are not in the header of a TAP stream.
{
    if (do_tap) {
        # We are converting the output to TAP format.
        if ($0 ~ /^(ERROR|FAIL):/ \
            || ( any_fail_seen && $0 ~ /^[ \t]/ )) {
            # The line is an error or failure message, or it is a continuation
            # of a previous error or failure message.
            report_failure(test_name, test_lines_count);
        }
    }
    else {
        # We are copying the TAP stream.
        if ($0 ~ /^[ \t]*#/) {
            # The line is a TAP comment.
            if (comments)
                print;
        }
        else {
            # The line is not a TAP comment.
            print;
        }
    }
}

END {
    if (bailout_seen)
        exit 1;

    if (plan_seen && test_results_count != test_results_expected) {
        # Handle the case where the test plan is not fulfilled.
        if (test_results_seen < test_results_expected) {
            if (any_fail_seen) {
                # Some tests have failed, others have been missed.  Assume
                # the missed tests would have been successes.
                msg = ""; 
            }
            else {
                # Some tests have been missed, but all the run tests have
                # succeeded.
                msg = ""; 
            }
        }
        else {
            # More tests have been run than stated in the plan.
            msg = ""; 
        }
        if (msg != "")
            print msg;
    }
    else if (! plan_seen && ! bail_out) {
        # Handle the case where there is no valid test plan.
        if (any_test_seen) {
            # Some test lines have been seen.
            if (any_skip_seen) {
                # Some tests have been skipped.  Assume the test count is
                # correct.
                msg = ""; 
            }
            else if (any_fail_seen) {
                # Some tests have failed.  Assume the test count is correct.
                msg = ""; 
            }
            else {
                # All tests have passed.  Assume the test count is correct.
                msg = ""; 
            }
        }
        else {
            # No tests have been seen at all.
            msg = "ERROR: No tests were run!";
            no_tests_run = 1;
            no_results = 1;
        }
        if (msg != "")
            print msg;
    }

    if (no_tests_run) {
        # Handle the case where no tests have been run.
        if (no_results) {
            # No useful results have been seen.
            if (! ignore_exit_code)
                exit 1;
        }
        else if (skip_all) {
            # The test plan indicates that all tests have been skipped.
            exit 0;
        }
        else {
            # No tests have been run, but we expected some to be run.
            if (! ignore_exit_code)
                exit 1;
        }
    }
    else if (any_fail_seen) {
        # Some tests have failed.
        if (! ignore_exit_code)
            exit 1;
    }
    else if (test_results_count < test_results_expected && ! any_todo_or_skip_seen) {
        # Some tests have been missed, and no tests have been skipped or
        # are TODO.
        if (! ignore_exit_code)
            exit 1;
    }
    else {
        # All is well.
        exit 0;
    }
}

function report_failure(test_name, test_number) {
    # We have a failure to report.
    if (! bailout_seen) {
        # We have not already bailed out.
        if (! any_fail_seen) {
            # This is the first failure.
            print "Bail out! " test_name " failed test #" test_number ":";
            bailout_seen = 1;
        }
    }
}
' >&3

# Save exit code in case we get interrupted.
st=$?

if test $merge = yes; then
  # Restore stdout and stderr.
  exec 1>&5 2>&6
  # Restore the original values of stdout and stderr.
  exec 5>&- 6>&-
fi

# If we've been interrupted, let's really quit.
# And use the correct exit code, from the test script.
test -n "$INT_TRAP" && exit $st

# Catch the exit code from the test script.
if test $st -eq 0; then
  if test $ignore_exit = no && test -s "$log_file"; then
    echo "$me: $test_name exited successfully but its output contains the word 'ERROR'" >&2
    st=1
  fi
else
  if test $ignore_exit = yes; then
    echo "$me: \$ignore_exit = yes, we pretend that $test_name passed" >&2
    st=0
  fi
fi

if test $st -eq 0; then
  # Preserve the count of successes.
  if test $expect_failure = yes; then
    echo "${red}XPASS${std}: $test_name" | cat >&2
    st=1
  else
    echo "${grn}PASS${std}: $test_name" | cat >&2
  fi
else
  # Preserve the count of failures.
  if test $expect_failure = yes; then
    echo "${lgn}XFAIL${std}: $test_name" | cat >&2
    st=0
  else
    echo "${red}FAIL${std}: $test_name" | cat >&2
  fi
fi

# Report the test outcome.
echo "$st" > "$trs_file"

# Remove the log file if there are no test failures.
if test $st -eq 0; then
  test -f "$log_file" && rm -f "$log_file"
fi

exit $st
